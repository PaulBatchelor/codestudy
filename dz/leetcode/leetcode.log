@2025-01-13#codestudy/leetcode/425

@18:45 Looking at backtracking
#! dz codestudy/leetcode/425/files/backtracking.py
This is the first editorial solution. It said it
would trigger a TLE, but it didn't trigger on my
first submission. So it seems good enough. I'm studying
it first.

@20:21 Grokking getWordsWithPrefix
#! dz codestudy/leetcode/425/files/backtracking.py/solution_class/getWordsWithPrefix
#! dz python/docs/reference/expressions/yield
#! dz rust/std/iter

This one is very pythonic, since it is making use of
generator syntax and yield(). My assumption here is that
it's a little more efficient than making an array.
---
A generator is a bit like an iterator in Rust in this context.
We are building a list of words that have a particular
prefix. instead of making a list and iterating through
the list, the generator skips the list-making
process and just goes to the iterating bit.

@20:45 Conclusions on backtracking algorithm today
#! dz codestudy/leetcode/425/files/backtracking.py
#! dz codestudy/leetcode/425/files/2025_01_10.py
I've now done a fairly comprehenisve dive into
the editorial naive backtracking solution and my own
solution. The underlying question I wanted to answer
was: why does mine TLE and their solution doesn't?
My guess is that the inner loop was more optimized,
making used of generators and yield syntax.

@2025-01-16#codestudy/leetcode/110

@10:46 Setup
#! dz codestudy/leetcode/110/files/2025_01_16.py
Still figuring out how to manage this codestudy infra

@11:01 Added editorial solution
#! dz codestudy/leetcode/110/files/editorial_top_down.py

@11:12 Negative one return value makes me think a bit
#! dz codestudy/leetcode/110/files/editorial_top_down.py/height_function/return_negative_one_on_empty_tree 
#! dz codestudy/leetcode/110/files/editorial_top_down.py/height_function/return_max_height_plus_one
I think looking at the return statement makes things clearer
maybe? This code is always adding 1 to the max result.
A height of zero will happen if there are no child nodes.
If there is one child node the height will be at least 1,
as the result will always be positive (zero inclusive).

@2025-01-16#codestudy/leetcode/872

@12:30 initial setup
#! dz codestudy/leetcode/872/files/editorial.py
I am studying the solution more closely because I'm
still getting the hang of generator and yield syntax.

@12:46 yield from syntax
#! dz codestudy/leetcode/872/files/editorial.py/leafSimilar/dfs/if_node/yield_from_children
It's the "from" keyword that is new to me here, so I am
sounding it out.
---
dfs returns a "generator", similar to what "range" does.
---
generators are build up using yield. I think of coroutines
when I think of yield. Is it like special return to
a generator? or a suspension?
---
"yield from" seems to loosely imply "return values from
this generator".
---
Under the hood, I realize that this isn't a list data
structure, but some kind of iterator patter.

@12:50 return explanation
#! dz codestudy/leetcode/872/files/editorial.py/leafSimilar/return_list_comp 
As I've established previously, the call to dfs returns
a generator, which needs to be converted to a list.
This does an in-place list conversion for both trees,
then applies a comparison between both of those
resulting lists.

@2025-01-19#codestudy/leetcode/570

@17:17 This one requires some intuition to grok
#! dz codestudy/leetcode/560/files/editorial.py
This comes from the editorial for 437, path sum iii.
The intuition for this always slips out of my mind.
My hope with this code study is that it will force
me to face this head-on and study this problem
line by line.
---
It's almost no code, and yet, the intuition to get here...

@17:30 The most unintuitive line for me right now
#! dz codestudy/leetcode/560/files/editorial.py/subArraySum/iterate_over_numbers/increment_count_from_hashmap
This here is the line that gets me the most confused.
---
The counter is being incremented by some amount in
the hashmap. The hashmap item being looked up
is the current prefix sum, minus the target value
K.
---
Since this hashmap is a default dictionary, the counter
will not get updated if there is no entry. Otherwise,
it won't get updated.

@17:39 Counter is updated in two places
#! dz codestudy/leetcode/560/files/editorial.py/subArraySum/iterate_over_numbers/increment_count_from_hashmap 
#! dz codestudy/leetcode/560/files/editorial.py/subArraySum/iterate_over_numbers/increment_count_if_psum_matches 
The first time is when the current prefix sum is
the target. This is intuitive for me. It says "if
all the numbers added up to this point are the target,
increment the counter by 1".
----
The second time the counter is incremented is when
it is by the hashmap. And this can increment the
variable by a variable amount, even zero. What
does this mean?
---
It says: Take the current prefix sum, go back by an
amount K, and see if this sum has appeared before.
If so, add how many times it has appeared so far.
---
psum marks a point in a sequence, the accumulative
amount traveled so far from the beginning. Perhaps
you can think of it as like a marker you leave on
the path. When you subtract K from psum, you are
taking the current point in time, and seeing
if there exists a previous point in time that was
seen K units ago.

@17:48 Trying to grok, why the counter works the way it does
#! dz codestudy/leetcode/560/files/editorial.py/subArraySum/iterate_over_numbers/increment_count_from_hashmap 
I've totally tried working this one out before.
---
When would prefix sums repeat? When negative values
are introduced, otherwise it would be increasing in only
one direction.

@17:52 prefix sum, not partial sum
#! dz codestudy/leetcode/560/files/editorial.py/subArraySum/initialize_variables
I was writing this one incorrectly. This might
better help me grok this actually calling it that.
Prefix sum: summation up to this point.

@17:55 Trying to articulate my confusion
#! dz codestudy/leetcode/560/files/editorial.py/subArraySum/iterate_over_numbers/increment_count_from_hashmap 
We are counting how many times a prefix occurs
---
It's difficult to convince myself that the prefix
counter works.

@18:05 Gotta keep moving unfortunately
#! dz codestudy/leetcode/560/files/editorial.py/subArraySum/iterate_over_numbers/increment_count_from_hashmap
I've been at this an hour

@2025-01-19#codestudy/leetcode/437

@18:17 Spinning this editorial solution up
I didn't get to solve this solution because I didn't really
understand prefix sum. I'm attempting to better grok
this python solution by mapping the code and annotating
it.

@18:31 I am going to cross examine both of these files
#! dz codestudy/leetcode/437/files/editorial.py
#! dz codestudy/leetcode/560/files/editorial.py
A cursory glance, I see similarities. It would be great
to make one-to-one connections. I'm going to rework
dzfiles so 437 and 560 can see eachother's nodes.

@18:51 key difference: 437 increments AND decrements the hashmap
#! dz codestudy/leetcode/437/files/editorial.py/pathSum/preorder/increment_hashmap 
#! dz codestudy/leetcode/437/files/editorial.py/pathSum/preorder/decrement_hashmap
#! dz codestudy/leetcode/560/files/editorial.py/subArraySum/iterate_over_numbers/increment_hashmap 
I've gone ahead and made connections between similar
line of code in 560 and 437. The biggest thing for me
that sticks out is the fact that the DFS recursive
preorder traversal requires incrementing the hashmap, calling
traversing the children, then decrementing the hashmap.
Currently trying grok what this means.

@18:58 undo is backtracking
#! dz codestudy/leetcode/437/files/editorial.py/pathSum/preorder/increment_hashmap 
#! dz codestudy/leetcode/437/files/editorial.py/pathSum/preorder/preorder_children 
#! dz codestudy/leetcode/437/files/editorial.py/pathSum/preorder/decrement_hashmap
Recursion has a way of backtracking. I'm not going to say
more on this because my brain is still sizzling from
the backtracking I saw when I first attempted this a few
hours ago.
The increment marks the prefix at the current node before
going in. The decrement unmarks it as an "undo".

@19:07 Big picture: how do these relate?
#! dz codestudy/leetcode/437/files/editorial.py
#! dz codestudy/leetcode/560/files/editorial.py
560: a problem that finds the number of unique subarrays
in an array that sum to a target value.
---
437: a problem problem that finds the number of unique subpaths
in a binary tree that sum to a target value.
---
An array structure is very similar to that of a path in
a binary tree, so this problem can be adapted to a DFS
solution for the binary tree. The modification is to
account for backtracking by marking/unmarking the hashmap
keeping track of prefix patterns.
