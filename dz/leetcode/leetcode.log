@2025-01-13#codestudy/leetcode/425

@18:45 Looking at backtracking
#! dz codestudy/leetcode/425/files/backtracking.py
This is the first editorial solution. It said it
would trigger a TLE, but it didn't trigger on my
first submission. So it seems good enough. I'm studying
it first.

@20:21 Grokking getWordsWithPrefix
#! dz codestudy/leetcode/425/files/backtracking.py/solution_class/getWordsWithPrefix
#! dz python/docs/reference/expressions/yield
#! dz rust/std/iter

This one is very pythonic, since it is making use of
generator syntax and yield(). My assumption here is that
it's a little more efficient than making an array.
---
A generator is a bit like an iterator in Rust in this context.
We are building a list of words that have a particular
prefix. instead of making a list and iterating through
the list, the generator skips the list-making
process and just goes to the iterating bit.

@20:45 Conclusions on backtracking algorithm today
#! dz codestudy/leetcode/425/files/backtracking.py
#! dz codestudy/leetcode/425/files/2025_01_10.py
I've now done a fairly comprehenisve dive into
the editorial naive backtracking solution and my own
solution. The underlying question I wanted to answer
was: why does mine TLE and their solution doesn't?
My guess is that the inner loop was more optimized,
making used of generators and yield syntax.

@2025-01-16#codestudy/leetcode/110

@10:46 Setup
#! dz codestudy/leetcode/110/files/2025_01_16.py
Still figuring out how to manage this codestudy infra

@11:01 Added editorial solution
#! dz codestudy/leetcode/110/files/editorial_top_down.py

@11:12 Negative one return value makes me think a bit
#! dz codestudy/leetcode/110/files/editorial_top_down.py/height_function/return_negative_one_on_empty_tree 
#! dz codestudy/leetcode/110/files/editorial_top_down.py/height_function/return_max_height_plus_one
I think looking at the return statement makes things clearer
maybe? This code is always adding 1 to the max result.
A height of zero will happen if there are no child nodes.
If there is one child node the height will be at least 1,
as the result will always be positive (zero inclusive).

@2025-01-16#codestudy/leetcode/872

@12:30 initial setup
#! dz codestudy/leetcode/872/files/editorial.py
I am studying the solution more closely because I'm
still getting the hang of generator and yield syntax.

@12:46 yield from syntax
#! dz codestudy/leetcode/872/files/editorial.py/leafSimilar/dfs/if_node/yield_from_children
It's the "from" keyword that is new to me here, so I am
sounding it out.
---
dfs returns a "generator", similar to what "range" does.
---
generators are build up using yield. I think of coroutines
when I think of yield. Is it like special return to
a generator? or a suspension?
---
"yield from" seems to loosely imply "return values from
this generator".
---
Under the hood, I realize that this isn't a list data
structure, but some kind of iterator patter.

@12:50 return explanation
#! dz codestudy/leetcode/872/files/editorial.py/leafSimilar/return_list_comp 
As I've established previously, the call to dfs returns
a generator, which needs to be converted to a list.
This does an in-place list conversion for both trees,
then applies a comparison between both of those
resulting lists.
